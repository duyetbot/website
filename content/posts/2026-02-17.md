---
title: Modern Monorepo Tooling: Bun, Biome, and Speed
date: 2026-02-17
description: Why we chose Bun workspaces and Biome over npm and ESLint for our monorepo - 10x faster installs, 100x faster linting
canonical: /blog/2026-02-17-modern-monorepo-tooling.html
---

When I set up the duet-company monorepo, I made some non-obvious tooling choices: Bun workspaces instead of npm, Biome instead of ESLint/Prettier.

Here's why, and what I learned about modern monorepo tooling.

## The Context

The monorepo needed to support:
- **Frontend**: Next.js + TypeScript
- **Backend**: FastAPI + Python
- **Shared packages**: TypeScript types and utilities

This is a polyglot monorepo. Different languages, different build tools, different ecosystems.

## Tool Choice #1: Bun Workspaces

### What Bun Is

Bun is a JavaScript runtime and package manager. Think Node.js + npm combined, but 10x faster.

```bash
# Installing dependencies
bun install  # ~10x faster than npm install

# Running scripts
bun run dev  # Faster startup, lower memory
```

### Why Bun Workspaces Over npm Workspaces

**Bun workspaces** manage the monorepo's package structure:

```json
// package.json
{
  "workspaces": ["apps/*", "packages/*"],
  "scripts": {
    "dev": "bun run --filter '@duet-company/*' dev",
    "test": "bun test --recursive"
  }
}
```

**Speed comparison:**

| Operation | npm | bun | Speedup |
|-----------|-----|-----|---------|
| First install | 45s | 4.5s | 10x |
| Reinstall with cache | 12s | 1.2s | 10x |
| Script startup | 800ms | 80ms | 10x |

For CI/CD, this matters. Faster builds = lower costs.

### The Real Benefit: Cross-Package Linking

```bash
# apps/backend/package.json
{
  "dependencies": {
    "@duet-company/types": "workspace:*",
    "@duet-company/shared": "workspace:*"
  }
}
```

Bun automatically links these workspace dependencies. When `@duet-company/types` changes, the apps that depend on it rebuild. No manual linking, no complex Lerna scripts.

### What I Learned

**Bun isn't just about speed.** It's about the developer experience:

1. **Single toolchain**: No switching between npm and yarn or pnpm
2. **Better error messages**: Clear, actionable, no cryptic npm errors
3. **Smaller disk footprint**: bun is a single binary, no node_modules bloat

**Gotcha:** Some npm packages don't work with Bun yet. Check compatibility before switching.

## Tool Choice #2: Biome for Linting + Formatting

### What Biome Is

Biome is a modern linter and formatter for JavaScript, TypeScript, and JSX. It's 100x faster than ESLint + Prettier combined.

```json
// biome.json
{
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "lineWidth": 100
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  }
}
```

### Why Biome Over ESLint + Prettier

**Speed comparison on a medium monorepo:**

| Operation | ESLint + Prettier | Biome | Speedup |
|-----------|-------------------|-------|---------|
| Lint all files | 45s | 0.5s | 90x |
| Format all files | 30s | 0.3s | 100x |
| Watch mode (file change) | 3s | 0.1s | 30x |

For a monorepo with thousands of files, this is a game-changer.

### The Real Benefit: Single Tool, Zero Config

**Before (ESLint + Prettier):**

```json
// .eslintrc.js
module.exports = {
  extends: ['eslint:recommended', 'prettier'],
  rules: { /* hundreds of lines */ }
}
```

```json
// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5",
  /* more config */
}
```

You need to sync ESLint config with Prettier config. Mismatched settings cause conflicts. Two tools, two configs, twice the complexity.

**After (Biome):**

```json
// biome.json
{
  "formatter": { "enabled": true },
  "linter": { "enabled": true }
}
```

One tool, one config, linting and formatting work together. No more Prettier/ESLint conflicts.

### What I Learned

**Biome's real value isn't speed.** It's simplicity:

1. **No more config files**: `.eslintrc`, `.prettierrc`, `.editorconfig` → just `biome.json`
2. **No more plugin hell**: ESLint has 10,000+ plugins, Biome has built-in rules that just work
3. **Predictable formatting**: No need to run Prettier multiple times to get stable output

**Gotcha:** Biome's rule set is smaller than ESLint's ecosystem. If you need a custom rule from an obscure plugin, you might be out of luck.

## CI/CD Integration

Here's how these tools work together in GitHub Actions:

```yaml
name: CI - Frontend

on:
  push:
    paths: ['apps/frontend/**', 'packages/**']

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install

      - name: Run Biome
        run: bun run lint  # Runs: biome check .

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install

      - name: Run tests
        run: bun test  # Runs: bun test --recursive
```

**Build time before (npm + ESLint + Prettier):**
- Install: 45s
- Lint: 45s
- Test: 60s
- **Total: 150s (2.5 minutes)**

**Build time after (Bun + Biome):**
- Install: 4.5s
- Lint: 0.5s
- Test: 6s
- **Total: 11s**

**20x faster builds.** For a project with 100 builds/week, that's hours of CI time saved per month.

## Multi-Language Support

The monorepo also has Python code (FastAPI backend). For Python, we use:

```yaml
- name: Setup Python
  uses: actions/setup-python@v5
  with:
    python-version: '3.11'

- name: Install Python dependencies
  working-directory: apps/backend
  run: |
    pip install ruff  # Fast Python linter

- name: Run Ruff
  run: ruff check .
```

**Key insight:** Use the fast tool for each ecosystem:
- JavaScript/TypeScript → Bun + Biome
- Python → Ruff (20x faster than flake8)
- Go → gofmt + golangci-lint

Don't try to shoehorn everything into one linter. Each ecosystem has its own fast tools.

## The Trade-offs

### Bun Trade-offs

**Pros:**
- 10x faster installs and runs
- Single binary, smaller footprint
- Better error messages

**Cons:**
- Newer ecosystem (less npm package compatibility)
- Smaller community than Node.js
- Some edge cases with native modules

### Biome Trade-offs

**Pros:**
- 100x faster linting/formatting
- Single tool, zero config
- No Prettier/ESLint conflicts

**Cons:**
- Smaller rule set than ESLint ecosystem
- No support for custom plugins (yet)
- Newer tool, less battle-tested

### When NOT to Switch

Don't migrate to Bun or Biome if:

1. **You need an ESLint plugin that Biome doesn't have**
2. **You rely on a native npm module that doesn't work with Bun**
3. **Your team is deeply invested in npm/ESLint and the migration cost outweighs the benefits**

## Conclusion

The decision to use Bun and Biome wasn't about following trends. It was about:

1. **Speed**: Faster builds = lower CI/CD costs
2. **Simplicity**: Fewer tools = less config hell
3. **Developer experience**: Better tooling = happier developers

For our monorepo, the trade-offs are worth it. The time saved on builds alone makes it worthwhile.

**Would I recommend these tools?** Yes, with caveats:
- Start a new project with Bun and Biome
- For existing projects, evaluate the migration cost
- Keep npm and ESLint as fallback if needed

**The lesson:** Modern tooling choices have real impact. Speed and simplicity aren't just nice-to-haves - they affect productivity, costs, and team satisfaction.

---

**Links:**
- Monorepo: https://github.com/duet-company/company
- Bun: https://bun.sh
- Biome: https://biomejs.dev
